# Copyright (c) 2013 Jason Ish
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

"""Provide mappings from ID's to descriptions.

Includes mapping classes for event ID messages and classification
information.
"""

from __future__ import print_function

import sys
import re

class MsgMapEntry(object):
    """ This class represents an entry in the MsgMap.

    :param gid: Generator ID of this map entry.
    :param sid: Signature ID of this map entry.
    :param sid: The message/description for this rule.
    :param refs: List of references for this rule.

    The parameters above are intended to be accessed directly.
    """

    def __init__(self, gid, sid, msg, refs=None):
        self.gid = gid
        self.sid = sid
        self.msg = msg
        if refs:
            self.refs = refs
        else:
            self.refs = []

    def __repr__(self):
        return "%d || %d || %s || %s" % (
            self.gid, self.sid, self.msg, ",".join(self.refs))

class MsgMap(object):
    """ This class implements of map of event descriptions useful for
    looking up an event description by its gid and sid.
    """

    def __init__(self):
        self.map = {}

    def get(self, gid, sid):
        """ Get a MsgMapEntry by gid and sid.

        :param gid: The generator ID of the event rule to lookup.
        :param sid: The signature ID of the event rule to looiup.

        :returns: A :py:class:`.MsgMapEntry` will be returned if an
          entry for the provided gid, sid was found otherwise None will
          be returned.

        A special case is made for gid 3, if an entry is found it will
        be checked for again with gid 1.
        """

        entry_id = (gid, sid)
        if entry_id in self.map:
            return self.map[entry_id]

        # Try to do the best thing.  If the gid is 3, try again with
        # gid 1.
        if gid == 3:
            return self.get(1, sid)

        return None

    def add_entry(self, entry):
        """ A a MsgMapEntry to the map. """
        self.map[(entry.gid, entry.sid)] = entry

    def load_sidmsg_file(self, filename, gid=1):
        """ Load a sid-msg.map style file as provided by a Snort
        ruleset or generated by pulledpork.
        """
        with open(filename) as fileobj:
            for line in fileobj:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                parts = [part.strip() for part in line.split("||")]
                entry = MsgMapEntry(gid, int(parts[0]), parts[1], parts[2:])
                self.add_entry(entry)

    def load_genmsg_file(self, filename):
        """ Load a gen-msg.map style file as provided by a Snort
        ruleset. 
        """
        with open(filename) as fileobj:
            for line in fileobj:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                gid, sid, msg = [part.strip() for part in line.split("||")]
                entry = MsgMapEntry(gid, sid, msg, None)
                self.add_entry(entry)

class Classification(object):
    """A class to represent a Snort rule classification.

    :param name: The classification short name.
    :param description: The classification description (or long name).
    :param priority: The priority of this classification as an integer.

    """

    def __init__(self, name, description, priority):
        self.name = name
        self.description = description
        self.priority = priority

    def __repr__(self):
        return "name=%s; description=%s; priority=%d" % (
            self.name, self.description, self.priority)

class ClassificationMap(object):
    """ClassificationMap maps classification IDs and names to a
    :class:`.Classification` object.

    :param fileobj: (Optional) A file like object to load
      classifications from on initialization.

    Example::

        >>> from idstools import maps
        >>> class_map = maps.ClassificationMap()
        >>> class_map.load_from_file(open("etc/classification.config"))

        >>> class_map.get(3)
        name=bad-unknown; description=Potentially Bad Traffic; priority=2
        >>> class_map.getByName("bad-unknown")
        name=bad-unknown; description=Potentially Bad Traffic; priority=2

        >>> classification = class_map.get(5)
        >>> classification.name
        'successful-recon-limited'
        >>> classification.description
        'Information Leak'
        >>> classification.priority
        2

    """

    def __init__(self, fileobj=None):
        self.byId = []
        self.byName = {}

        if fileobj:
            self.load_from_file(fileobj)

    def add(self, classification):
        """Add a :class:`.Classification` to the map."""
        self.byId.append(classification)
        self.byName[classification.name] = classification

    def get(self, class_id):
        """Get a classification by ID.

        :param class_id: The classification ID to get.

        :returns: A :class:`.Classification` if found or None.

        """
        if 0 < class_id <= len(self.byId):
            return self.byId[class_id - 1]
        else:
            return None

    def getByName(self, name):
        """Get a classification by name.

        :param name: The name of the classification

        :returns: A :class:`.Classification` if found or None.

        """
        if name in self.byName:
            return self.byName[name]
        else:
            return None

    def load_from_file(self, fileobj):
        """Load classifications from a Snort style
        classification.config file object.

        """
        pattern = "config classification: ([^,]+),([^,]+),([^,]+)"
        for line in fileobj:
            m = re.match(pattern, line.strip())
            if m:
                self.add(
                    Classification(m.group(1), m.group(2), int(m.group(3))))
